#!/usr/bin/env python3
"""
Simple ASN.1 extractor: find top-level definitions and recursively
collect referenced types for given root type names.

Usage:
    python extract_asn1_defs.py [--asn FILE] [--out DIR] [names...]

If no names are given, a default list (from the user) is used.
"""
import os
import re
import sys
import argparse


DEFAULT_NAMES = [
    "CSFBParametersResponseCDMA2000",
    "DLInformationTransfer",
    "HandoverFromEUTRAPreparationRequest",
    "MobilityFromEUTRACommand",
    "RRCConnectionReconfiguration",
    "RRCConnectionRelease",
    "SecurityModeCommand",
    "UECapabilityEnquiry",
    "CounterCheck",
    "UEInformationRequest-r9",
    "LoggedMeasurementConfiguration-r10",
    "RNReconfiguration-r10",
    "RRCConnectionResume-r13",
    "DLDedicatedMessageSegment-r16",
]


def read_asn1(file_path):
    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
        return f.read()

# 找到每一个最小的ASN.1定义块
def find_top_level_definitions(asn_text):
    # Find all occurrences of '<Name> ::=' at start of line (allow leading spaces)
    name_re = re.compile(r'(?m)^[ \t]*([A-Za-z][A-Za-z0-9]*(?:-[A-Za-z0-9]+)*)\s*::=')
    matches = list(name_re.finditer(asn_text))
    defs = {}
    positions = []
    for m in matches:
        positions.append((m.start(), m.group(1)))

    # Add end marker
    positions.append((len(asn_text), None))

    for i in range(len(positions)-1):
        # 利用“下一个定义的开始位置”，来决定“当前定义的结束位置”
        start_pos, name = positions[i]
        end_pos = positions[i+1][0]
        # Extract block and strip leading/trailing blank lines
        block = asn_text[start_pos:end_pos].rstrip() + "\n"
        defs[name] = block

    return defs

# 提取每个ASN.1定义块中引用的类型名称
def extract_references(def_text, candidate_names):
    # Token regex to capture identifiers including hyphenated names like 'UEInformationRequest-r9'
    token_re = re.compile(r'[A-Za-z][A-Za-z0-9]*(?:-[A-Za-z0-9]+)*')
    tokens = set(token_re.findall(def_text))
    # Intersect with candidate names
    # 保证找到的都是有效的类型名称,因为再ASN.1定义块中存在
    return {t for t in tokens if t in candidate_names}



# 递归收集所有依赖的ASN.1定义块
def collect_recursive(root_name, defs):
    if root_name not in defs:
        return None, [f"Type '{root_name}' not found in ASN.1 file."]
    # 存储结果的有序列表，每个order对应一个顶级ASN.1Message对应的所有定义块
    # 作为结果输出所有相关的ASN.1定义块
    order = []
    # 使用集合来跟踪已经处理过的类型，避免重复处理
    seen = set()
    stack = [root_name]
    # 作为结果输出所有没找到的ASN.1定义块
    warnings = []
    # 广度优先遍历
    while stack:
        name = stack.pop(0)
        if name in seen:
            continue
        # 标记为已处理
        seen.add(name)
        # 获取最小的ASN.1定义块
        definition = defs.get(name)
        if definition is None:
            warnings.append(f"Referenced type '{name}' not found.")
            continue
        order.append((name, definition))
        # 提取所有引用的类型名称
        refs = extract_references(definition, defs.keys())
        # remove self-reference
        # 遗弃已经提取过的ASN.1类型名称
        refs.discard(name)
        # add any refs that are not yet seen
        for r in sorted(refs):
            if r not in seen and r not in stack:
                stack.append(r)

    return order, warnings

# 获取文件名称
def sanitize_filename(name):
    return re.sub(r'[^A-Za-z0-9_.-]', '_', name) + '.asn'


def write_output(out_dir, root_name, collected):
    os.makedirs(out_dir, exist_ok=True)
    fname = sanitize_filename(root_name)
    path = os.path.join(out_dir, fname)
    with open(path, 'w', encoding='utf-8') as f:
        f.write('-- Extracted ASN.1 definitions for: %s\n' % root_name)
        f.write('-- Generated by extract_asn1_defs.py\n\n')
        for name, block in collected:
            f.write(block)
            f.write('\n')
    return path


def main():
    parser = argparse.ArgumentParser(description='Extract ASN.1 definitions recursively for given root types')
    parser.add_argument('--asn', '-a', help='ASN.1 source file', default='36331-j00.asn')
    parser.add_argument('--out', '-o', help='Output directory', default='extracted')
    # '*' 代表 “零个或多个”。
    # 它会把命令行中剩下的所有参数收集起来，打包成一个 Python 列表 (List)。如果你什么都不输，它就是一个空列表 []。
    parser.add_argument('names', nargs='*', help='Root type names to extract')
    args = parser.parse_args()

    names = args.names if args.names else DEFAULT_NAMES

    if not os.path.isabs(args.asn):
        asn_path = os.path.join(os.getcwd(), args.asn)
    else:
        asn_path = args.asn

    if not os.path.exists(asn_path):
        print(f"ASN.1 file not found: {asn_path}")
        sys.exit(2)
    # 获取文件中的所有内容到内存
    text = read_asn1(asn_path)
    defs = find_top_level_definitions(text)

    print(f"Found {len(defs)} top-level definitions in {asn_path}")

    results = []
    for root in names:
        print(f"Processing: {root}")
        collected, warnings = collect_recursive(root, defs)
        if collected is None:
            print('\tERROR:', warnings[0])
            continue
        out_path = write_output(os.path.join(os.path.dirname(asn_path), args.out), root, collected)
        print(f"\tWrote {len(collected)} definitions to {out_path}")
        for w in warnings:
            print('\tWarning:', w)
        results.append((root, out_path))

    print('\nDone. Generated files:')
    for r, p in results:
        print(f" - {r}: {p}")


if __name__ == '__main__':
    main()
